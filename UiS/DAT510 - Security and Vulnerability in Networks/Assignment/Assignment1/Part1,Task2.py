import time, timeit

MAX_KEY_LENGTH = 25
alphabet = 'abcdefghijklmnopqrstuvwxyz'

# Array containing the relative frequency of each letter in the English language
# https://en.wikipedia.org/wiki/Letter_frequency
english_frequences = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,
                      0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,
                      0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,
                      0.00978, 0.02360, 0.00150, 0.01974, 0.00074]


# this function took from https://github.com/drewp41/Vigenere-Cipher-Breaker
def getIndexOfCoincidence(ciphertext):
    N = float(len(ciphertext))
    frequency_sum = 0.0
    for letter in alphabet:
        frequency_sum += ciphertext.count(letter) * (ciphertext.count(letter) - 1)
    ic = frequency_sum / (N * (N - 1))
    return ic


# this function took from https://github.com/drewp41/Vigenere-Cipher-Breaker
def getKeyLength(ciphertext):
    ic_table = []

    for guess_len in range(MAX_KEY_LENGTH):
        ic_sum = 0.0
        avg_ic = 0.0
        for i in range(guess_len):
            sequence = ""
            for j in range(0, len(ciphertext[i:]), guess_len):
                sequence += ciphertext[i + j]
            ic_sum += getIndexOfCoincidence(sequence)
        if not guess_len == 0:
            avg_ic = ic_sum / guess_len
        ic_table.append(avg_ic)

    #print(ic_table)
    best_guess = ic_table.index(sorted(ic_table, reverse=True)[0])
    second_best_guess = ic_table.index(sorted(ic_table, reverse=True)[1])

    if best_guess % second_best_guess == 0:
        return second_best_guess
    else:
        return best_guess


# this function took from https://github.com/drewp41/Vigenere-Cipher-Breaker
def frequencyAnalysis(sequence):
    all_chi_squareds = [0] * 26

    for i in range(26):

        chi_squared_sum = 0.0
        sequence_offset = [chr(((ord(sequence[j]) - 97 - i) % 26) + 97) for j in range(len(sequence))]
        v = [0] * 26
        for l in sequence_offset:
            v[ord(l) - ord('a')] += 1
        for j in range(26):
            v[j] *= (1.0 / float(len(sequence)))
        for j in range(26):
            chi_squared_sum += ((v[j] - float(english_frequences[j])) ** 2) / float(english_frequences[j])

        all_chi_squareds[i] = chi_squared_sum

    shift = all_chi_squareds.index(min(all_chi_squareds))

    return chr(shift + 97)


def getActualKey(ciphertext, key_length):
    key = ''
    for i in range(key_length):
        sequence = ""
        for j in range(0, len(ciphertext[i:]), key_length):
            sequence += ciphertext[i + j]
        key += frequencyAnalysis(sequence)
    #print(key)
    return key


def generateBigKey(string, key):
    key = list(key)
    if len(string) == len(key):
        return (key)
    else:
        for i in range(len(string) - len(key)):
            key.append(key[i % len(key)])
    return ("".join(key))


def cipherTextDecryption(ciphertext, key):
    start_time = timeit.default_timer()
    orig_text = []
    #print("key is " + key)
    tempText = ''
    for i in range(len(ciphertext)):
        x = (ord(ciphertext[i]) - ord(key[i])) % 26
        x = x + 65
        orig_text.append(chr(x))
        tempText = tempText + chr(x)
    end_time = timeit.default_timer()
    total_time = "%.2gs" % (end_time-start_time)
    #total_time = (time.time() - start_time)*1000
    #print("%.2gs" % (end_time-start_time))
    print("Total Execution Time: " + str(total_time))
    return tempText


def newAlphabet(ch):
    ch = ch.lower()
    alph = 'abcdefghijklmnopqrstuvwxyz'
    new_alph = alph[alph.index(ch):] + alph[:alph.index(ch)]
    return new_alph


def cipherTextEncryption(text, big_key):
    res = ''
    engAlphabet = 'abcdefghijklmnopqrstuvwxyz'
    i = 1
    for char in big_key:
        new = newAlphabet(char)
        for t in text:
            if engAlphabet.count(t) == 1:
                res += new[engAlphabet.index(t)]
                text = text[i:]
                break
            elif engAlphabet.count(t.lower()) == 1:
                res += new[engAlphabet.index(t.lower())].upper()
                text = text[i:]
                break
            else:
                res += t
                text = text[i:]
                break
            i += 1
    return res


def main():
    ask = True
    while ask:
        choice = input("Enter 1 to encryption or 2 to decryption: ")
        if choice == '1':
            unfilteredText = input("Enter the plaintext for encryption: ")
            unfilteredKey = input("Enter the key for encryption: ")

            plaintext = ''.join(x.lower() for x in unfilteredText if x.isalpha())
            # print(plaintext)
            key = ''.join(x.lower() for x in unfilteredKey if x.isalpha())
            # print(key)
            keyword = generateBigKey(plaintext, key)
            ciphertext = cipherTextEncryption(plaintext, keyword).upper()
            print("Ciphertext: " + str(ciphertext))

            ask = False
        elif choice == '2':
            ciphertext_unfiltered = input("Enter the ciphertext for decryption: ")
            ciphertext = ''.join(x.lower() for x in ciphertext_unfiltered if x.isalpha())

            checkKnownKey = True
            while checkKnownKey:
                isKeyKnown = input("Enter y to key in known or n to unknown: ")

                if isKeyKnown == 'n':

                    key_length = getKeyLength(ciphertext)
                    print("Possible key length: " + str(key_length))

                    key = getActualKey(ciphertext, key_length)
                    repkey = generateBigKey(ciphertext_unfiltered, key)
                    plaintext = cipherTextDecryption(ciphertext, repkey)

                    #print("The secret key is: " + key)
                    #print("Plaintext: " + plaintext)

                    checkKnownKey = False
                elif isKeyKnown == 'y':

                    unfilteredKey = input("Enter the secrect key to decrypt: ")
                    key = ''.join(x.lower() for x in unfilteredKey if x.isalpha())
                    repkey = generateBigKey(ciphertext_unfiltered, key)
                    plaintext = cipherTextDecryption(ciphertext, repkey)

                    print("Plaintext: " + plaintext)

                    checkKnownKey = False
                else:
                    print("Not a valid input")

            ask = False
        else:
            print("Input not valid please try again")


if __name__ == '__main__':
    main()
