import itertools


class KeyGeneration:
    key = []
    k1 = []
    k2 = []
    #flag = 0

    def GenerateKeys(self, inputkey):
        key = []
        cl = ''
        ts = ''
        i = 0
        while i < 10:
            cl = inputkey[i]
            ts = cl
            key.append(int(ts))
            i = i + 1

        KeyGeneration.key = key
        self.p10Permutation()
        self.leftShiftLSOne()
        self.k1 = self.p8Permutation()
        self.leftShiftLSTwo()
        self.k2 = self.p8Permutation()
        self.flag = 1

    def p10Permutation(self):
        temp = [self.key[2], self.key[4], self.key[1], self.key[6], self.key[3], self.key[9], self.key[0], self.key[8],
                self.key[7], self.key[5]]
        self.key = temp

    def leftShiftLSOne(self):
        temp = [self.key[1], self.key[2], self.key[3], self.key[4], self.key[0], self.key[6], self.key[7], self.key[8],
                self.key[9], self.key[5]]
        self.key = temp

    def p8Permutation(self):
        temp = [self.key[5], self.key[2], self.key[6], self.key[3], self.key[7], self.key[4], self.key[9], self.key[8]]
        return temp

    def leftShiftLSTwo(self):
        temp = [self.key[2], self.key[3], self.key[4], self.key[0], self.key[1], self.key[7], self.key[8], self.key[9],
                self.key[5], self.key[6]]
        self.key = temp

    def getKOne(self):
        return self.k1

    def getKTwo(self):
        return self.k2


class Encryption:
    K1 = []
    K2 = []
    pt = []

    def SaveParameters(self, plaintext, k1, k2):
        pt = []
        cl = ''
        ts = ''
        i = 0

        while i < 8:
            cl = plaintext[i]
            ts = cl
            pt.append(int(ts))
            i = i + 1

        self.pt = pt
        self.K1 = k1
        self.K2 = k2

    def initialPermutation(self):
        temp = [self.pt[1], self.pt[5], self.pt[2], self.pt[0], self.pt[3], self.pt[7], self.pt[4], self.pt[6]]
        self.pt = temp

    def inverseInitialPermutation(self):
        temp = [self.pt[3], self.pt[0], self.pt[2], self.pt[4], self.pt[6], self.pt[1], self.pt[7], self.pt[5]]
        self.pt = temp

    def BtoDconver(self, b1, b2):
        temp = 0
        base = 1
        bits = [b1, b2]
        i = len(bits) - 1
        while i >= 0:
            temp = temp + (bits[i] * base)
            base = base * 2
            i = i - 1

        # print(temp)
        return temp

    def DtoBConver(self, numb):
        numb = int(numb)
        # print(numb)
        if numb == 0:
            zero = [0, 1]
            return zero

        temp = []
        count = 0
        i = 0

        a = bin(2).replace("0b", "")
        li = list(map(int, str(a)))
        # print(li)

        while numb != 0:
            temp.append(numb % 2)
            numb = int(numb / 2)
            # print(numb)
            i = i + 1
            count = count + 1

        # temp = li
        temp2 = []
        i = count - 1
        j = 0

        while i >= 0 and j < count:
            # print(i)
            temp2.append(temp[i])
            i = i - 1
            j = j + 1

        if count < 2:
            temp = []
            temp.append(0)
            temp.append(temp2[0])
            return temp

        # print(temp)
        # print(temp2)
        # print(zero)
        return temp2

    def mappingF(self, R, SK):
        temp = [self.pt[3], self.pt[0], self.pt[1], self.pt[2], self.pt[1], self.pt[2], self.pt[3], self.pt[0]]

        temp[0] = temp[0] ^ SK[0]
        temp[1] = temp[1] ^ SK[1]
        temp[2] = temp[2] ^ SK[2]
        temp[3] = temp[3] ^ SK[3]
        temp[4] = temp[4] ^ SK[4]
        temp[5] = temp[5] ^ SK[5]
        temp[6] = temp[6] ^ SK[6]
        temp[7] = temp[7] ^ SK[7]

        print("XOR Result: " + str(temp))

        S0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]
        S1 = [[0, 1, 2, 3], [2, 0, 1, 3], [3, 0, 1, 0], [2, 1, 0, 3]]
        d11 = temp[0]
        d14 = temp[3]

        #ab = BinaryOp()
        # row1 = BinaryOp.BinToDec(d11, d14)
        row1 = self.BtoDconver(d11, d14)

        # print (d11, d14)

        d12 = temp[1]
        d13 = temp[2]
        # col1 = BinaryOp.BinToDec(d12, d13)
        col1 = self.BtoDconver(d12, d13)

        o1 = S0[row1][col1]
        out1 = []
        # out1 = BinaryOp.DecToBinArr(o1)
        # out1.append(BinaryOp.DecToBinArr(o1))
        # print(self.DtoBConver(o1))
        out1 = self.DtoBConver(o1)

        d21 = temp[4]
        d24 = temp[7]

        # row2 = BinaryOp.BinToDec(d21, d24)
        row2 = self.BtoDconver(d21, d24)

        d22 = temp[5]
        d23 = temp[6]

        # col12 = BinaryOp.BinToDec(d22, d23)
        col12 = self.BtoDconver(d22, d23)
        o2 = S1[row2][col12]

        out2 = []
        # out2.append(self.DtoBConver(o2))
        out2 = self.DtoBConver(o2)
        # out2.append(BinaryOp.DecToBinArr(o2))
        # out2 = BinaryOp.DecToBinArr(o2)

        O_Per = []
        out = []
        out.append(out1[0])
        out.append(out1[1])
        out.append(out2[0])
        out.append(out2[1])
        # out = [out1[0], out1[1], out2[0], out2[1]]
        O_Per = [out[1], out[3], out[2], out[0]]

        return O_Per

    def FunctionFK(self, L, R, SK):
        temp = []
        out = []

        temp = self.mappingF(R, SK)

        out.append(L[0] ^ temp[0])
        out.append(L[1] ^ temp[1])
        out.append(L[2] ^ temp[2])
        out.append(L[3] ^ temp[3])

        out.append(R[0])
        out.append(R[1])
        out.append(R[2])
        out.append(R[3])

        return out

    def switchSW(self, inner):
        inner = list(itertools.chain.from_iterable(inner))
        temp = [inner[4], inner[5], inner[6], inner[7], inner[0], inner[1], inner[2], inner[3]]
        return temp

    def encrypt(self, plaintext, LK, RK):
        self.SaveParameters(plaintext, LK, RK)
        self.initialPermutation()
        LH = []
        RH = []
        LH.append(self.pt[0])
        LH.append(self.pt[1])
        LH.append(self.pt[2])
        LH.append(self.pt[3])

        RH.append(self.pt[4])
        RH.append(self.pt[5])
        RH.append(self.pt[6])
        RH.append(self.pt[7])
        r1 = []
        r1.append(self.FunctionFK(LH, RH, self.K1))

        temp = []
        temp.append(self.switchSW(r1))
        temp = list(itertools.chain.from_iterable(temp))
        LH[0] = temp[0]
        LH[1] = temp[1]
        LH[2] = temp[2]
        LH[3] = temp[3]

        RH[0] = temp[4]
        RH[1] = temp[5]
        RH[2] = temp[6]
        RH[3] = temp[7]
        r2 = []
        r2 = self.FunctionFK(LH, RH, self.K2)
        self.pt = r2

        self.inverseInitialPermutation()
        print("The result is: " + str(self.pt))

        return self.pt

def main():
    KG = KeyGeneration()
    enc = Encryption()

    choice = input("Enter 1 to encryption or 2 to decryption: ")
    if choice == '1':
        plainText8Bit = input("Enter binary 8 bit plaintext: ")
        key10Bit = input("Enter binary 10 bit key: ")
        #plainText8Bit = '01010101'
        #key10Bit = '1110001110'
        KG.GenerateKeys(key10Bit)
        cipherText = enc.encrypt(plainText8Bit, KG.getKOne(), KG.getKTwo())
    elif choice == '2':
        cipherText8Bit = input("Enter binary 8 bit ciphertext: ")
        key10Bit = input("Enter binary 10 bit key: ")
        KG.GenerateKeys(key10Bit)
        plainText = enc.encrypt(cipherText8Bit, KG.getKTwo(), KG.getKOne());
    else:
        print("Input not valid please try again")

if __name__ == '__main__':
    main()
