from random import randint
from hashlib import sha256
from sys import stdin

colorCodes = {
    'END': '\033[m',
    'BLACK': '\033[30;1m',
    'RED': '\033[31;1m',
    'GREEN': '\033[32;1m',
    'YELLOW': '\033[33;1m',
    'BLUE': '\033[34;1m',
    'PURPLE': '\033[35;1m',
    'CYAN': '\033[36;1m'
}


# implementing DSA (Digital Signature Algorithm)
# https://www.includehelp.com/cryptography/digital-signature-algorithm-dsa.aspx
class DSS(object):
    # Not a dummy constructor
    def __init__(self):
        self.privateKey = int()
        self.publicKey = int()
        self.fileHash = str()

    # Check a number if prime or not
    def checkPrime(self, num, test_count):
        if num == 1:
            return False
        if test_count >= num:
            test_count = num - 1
        for x in range(test_count):
            val = randint(1, num - 1)
            if pow(val, num - 1, num) != 1:
                return False
        return True

    # Generate prime of given bit length
    def getPrime(self, n):
        found_prime = False
        while not found_prime:
            p = randint(2 ** (n - 1), 2 ** n)
            if self.checkPrime(p, 1000):
                return p

    # Modular Multiplicative Inverse
    def mod_inverse(self, a, m):
        a = a % m;
        for x in range(1, m):
            if ((a * x) % m == 1):
                return (x)
        return (1)

    # Global parameters
    def globalParameterGeneration(self):

        primeDivisor = self.getPrime(10)
        # prime modulus must be greater than primedivisor
        primeModulus = self.getPrime(20)
        while ((primeModulus - 1) % primeDivisor != 0):
            primeModulus = self.getPrime(20)
            primeDivisor = self.getPrime(10)

        print("Random 10 bit prime divisor: ", primeDivisor)

        flag = True
        while (flag):
            h = randint(1, primeModulus - 1)
            # h must be in between 1 and primeModulus-1
            g = 1
            while (g == 1):
                g = pow(h, int((primeModulus - 1) / primeDivisor)) % primeModulus
            flag = False

        self.perUserKey(primeModulus, primeDivisor, g)
        return (primeModulus, primeDivisor, g)

    # Generate private and public keys
    def perUserKey(self, p, q, g):
        privateKey = int(
            input(colorCodes['BLUE'] + "Choose a private key between 1 to " + str(q - 1) + ": " + colorCodes['END']))

        publicKey = pow(g, privateKey) % p
        print("Randomly chosen Public key is: ", colorCodes['CYAN'], publicKey, colorCodes['END'])

        # returning private and public components
        self.privateKey = privateKey
        self.publicKey = publicKey
        return (privateKey, publicKey)

    # Sender side signature creation
    def createSignature(self, fileName, p, q, g, x):
        hash_component = self.hashText(fileName)
        print("Hash of the document is: ", colorCodes['PURPLE'], self.fileHash, colorCodes['END'])
        r = 0
        s = 0
        while (s == 0 or r == 0):
            k = randint(1, q - 1)
            r = ((pow(g, k)) % p) % q
            i = self.mod_inverse(k, q)

            # converting hex to binary
            hashed = int(hash_component, 16)
            s = (i * (hashed + (x * r))) % q

        return (r, s, k)

    # Create hash of messages from text file
    def hashText(self, fileName):
        with open(fileName) as file:
            text = file.read()
            self.fileHash = sha256(text.encode("UTF-8")).hexdigest()

        return self.fileHash

    def exitFunction(self):
        print("\nPRESS ENTER TO EXIT")
        stdin.readline()

    # Receiver side signature verification
    def signatureVerification(self, fileName, p, q, g, r, s, y):
        self.hashText(fileName)

        hashed = int(self.fileHash, 16)
        w = self.mod_inverse(s, q)
        u1 = (hashed * w) % q
        u2 = (r * w) % q
        v = ((pow(g, u1) * pow(y, u2)) % p) % q

        if (v == r):
            print("Hash of the document is: ", colorCodes['PURPLE'], self.fileHash, colorCodes['END'])
            print(colorCodes['GREEN'] + "The signature is valid!" + colorCodes['END'])
            self.exitFunction()
        else:
            print("Hash of document received is: ", colorCodes['PURPLE'], self.fileHash, colorCodes['END'])
            print(colorCodes['RED'] + "The signature is invalid!" + colorCodes['END'])


if __name__ == '__main__':

    print("*************** Alice ***************")
    alice = DSS()

    globalParameter = alice.globalParameterGeneration()
    p, q, g = globalParameter[0], globalParameter[1], globalParameter[2]

    # Sender's side (signing the document):
    aliceFileName = input(colorCodes['BLUE'] + "Enter the name of document to sign: " + colorCodes['END'])
    # aliceFileName = 'samplefile.txt'
    components = alice.createSignature(aliceFileName, p, q, g, alice.privateKey)
    r, s, k = components[0], components[1], components[2]

    # Receiver's side (verifying the sign):
    print("\n")
    print("*************** Bob ***************")
    bob = DSS()

    bobFileName = input(colorCodes['BLUE'] + "Enter the name of document to verify: " + colorCodes['END'])
    # bobFileName = 'samplefile.txt'
    bobPublicKey = int(input(colorCodes['BLUE'] + "Enter PublicKey: " + colorCodes['END']))
    bob.signatureVerification(bobFileName, p, q, g, r, s, bobPublicKey)
    if bobPublicKey != alice.publicKey and bob.fileHash != alice.fileHash:
        print(colorCodes['RED'] + "File hash and public key both are not matching" + colorCodes['END'])
        bob.exitFunction()
    elif bob.fileHash != alice.fileHash:
        print(colorCodes['RED'] + "File hashing doesn't match" + colorCodes['END'])
        bob.exitFunction()
    elif bobPublicKey != alice.publicKey:
        print(colorCodes['RED'] + "Public key doesn't match" + colorCodes['END'])
        bob.exitFunction()
