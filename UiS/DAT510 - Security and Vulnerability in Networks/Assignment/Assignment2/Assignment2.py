import hashlib, random, binascii, os
# please install - pip3 install pycryptodome
from Crypto import Random
from Crypto.Cipher import AES


# This class took from http://dandylife.net/blog/archives/295
# Modified some of the class functionalities for the assignment
class diffieHellmanSC(object):
    # predefined_p = 107
    predefined_g = 2

    # p, g, and publicKey should be open to the other party
    def __init__(self, p=None, g=None, privateKey=None, publicKey=None):
        self.sharedKey = ''
        if p is None or g is None:
            # self.p = self.predefined_p
            # print(self.predefined_p)
            self.p = self.primeGenerator()
            self.g = self.predefined_g
        else:
            self.p = p
            self.g = g

        if privateKey is None or publicKey is None:
            self.privateKey = privateKey
            # self.privateKey = self.generatePrivateKey()
            self.publicKey = self.generatePublicKey()
        else:
            self.privateKey = privateKey
            self.publicKey = publicKey

    # Generating random prime number using formula p=2q+1 where q is also a prime
    def primeGenerator(self):
        foundPrime = False

        while (foundPrime != True):
            primes = [i for i in range(0, 100) if self.checkIsPrime(i)]

            q = random.choice(primes)
            p = 2 * q + 1

            if self.checkIsPrime(p) == False:
                continue
            else:
                foundPrime = True
                return p

    # Validating the prime q also checking the random number if it is prime or not
    def checkIsPrime(self, integerValue):
        if (integerValue == 1):
            return False
        elif (integerValue == 2):
            return True;
        else:
            for x in range(2, integerValue):
                if (integerValue % x == 0):
                    return False
            return True

    # Generate private key
    def generatePrivateKey(self):
        return random.randint(2, self.p - 1)

    # Generate publice key
    def generatePublicKey(self):
        return pow(self.g, self.privateKey, self.p)

    # Generate secure key combination to ensure the security
    def generateKey(self, anotherKey):
        self.sharedSecret = pow(anotherKey, self.privateKey, self.p)
        s = hashlib.md5()  # Generating 128 bit key
        s.update(str(self.sharedSecret).encode('utf-8'))
        self.key = s.digest()

    # Generate shared key
    def getKey(self):
        sharedKey = binascii.hexlify(self.key).decode('utf-8')
        self.sharedKey = sharedKey
        return sharedKey

    # Get the shared key length. Currently used 128 bit md5
    def getKeySize(self):
        return len(self.key) * 8

    # A print function
    def showDHKeyExchange(self, printWord):
        if printWord == "prime":
            print("Prime (p): " + str(self.p))
        elif printWord == "generator":
            print("Generator (g): " + str(self.g))
        elif printWord == "privatekey":
            print("Private key: " + str(self.privateKey))
        elif printWord == "publickey":
            print("Public key: " + str(self.publicKey))
        elif printWord == "sharedsecret":
            print("Shared secret: " + str(self.sharedSecret))
        elif printWord == "sharedkey":
            print("Shared key: " + str(self.getKey()))
        elif printWord == "sizeofkey":
            print("Size of the key (bits):" + str(self.getKeySize()))


# Blum Blum Shub Pesudo Random Number Generator class
# Its use for encrypt the shared key of alice and bob
class CSPRNG(object):
    # A dummy constructor
    def __init__(self, p=None, g=None, privateKey=None, publicKey=None):
        ab = 4

    # Blum Blum Shub PRNG
    def bbsGenerator(self, n, seed):
        x = pow(seed, 2, n)
        while True:
            yield x % 128
            x = pow(x, 2, n)
        return x

    # Uses Blum Blum Shub generator to encrypt/decrypt text via XOR
    def bbsEncryptDecrypt(self, text, n, seed):
        # random.seed(text)
        bbs = self.bbsGenerator(n, seed)
        return ''.join(chr(x) for x in (ord(t) ^ next(bbs) for t in text))


# File encryption class using AES
# Some functionalities took from https://stackoverflow.com/questions/20852664/python-pycrypto-encrypt-decrypt-text-files-with-aes
# Remodified the functionalities for this assignment
# Tested only with .txt file
class aesFileEncryption(object):
    def __init__(self, p=None, g=None, privateKey=None, publicKey=None):
        self.fileWithExtension = []
        self.encryptedFileName = ''
        self.decryptedFileName = ''

    def pad(self, s):
        return s + b"\0" * (AES.block_size - len(s) % AES.block_size)

    # Formatting the filenames
    def fileNameSplitter(self, fileName):
        self.fileWithExtension = list(os.path.splitext(fileName))
        self.fileWithExtension[0] = self.fileWithExtension[0].split('/')[-1].split('.')[0]
        # return self.fileWithExtension

    # Encrypting the message of .txt file
    def encryptMessage(self, message, key):
        message = self.pad(message)
        iv = Random.new().read(AES.block_size)
        cipher = AES.new(key, AES.MODE_CBC, iv)
        # print(iv + cipher.encrypt(message))
        return iv + cipher.encrypt(message)

    # Decrypting the message of .txt file
    def decryptMessage(self, ciphertext, key):
        iv = ciphertext[:AES.block_size]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        plaintext = cipher.decrypt(ciphertext[AES.block_size:])
        return plaintext.rstrip(b"\0")

    # Encrypting file with new message and file name
    def encryptFile(self, fileName, key):
        self.fileNameSplitter(fileName)
        newFileName = self.fileWithExtension[0]
        newFileExtension = self.fileWithExtension[-1]
        with open(fileName, 'rb') as fileOperation:
            plaintext = fileOperation.read()
        enc = self.encryptMessage(plaintext, key)
        self.encryptedFileName = newFileName + ".ENCRYPTED" + newFileExtension
        with open(newFileName + ".ENCRYPTED" + newFileExtension, 'wb') as fileOperation:
            fileOperation.write(enc)

    # Decrypting file with new message and file name
    def decryptFile(self, fileName, key):
        self.fileNameSplitter(fileName)
        newFileName = self.fileWithExtension[0]
        newFileExtension = self.fileWithExtension[-1]
        with open(fileName, 'rb') as fileOperation:
            ciphertext = fileOperation.read()
        dec = self.decryptMessage(ciphertext, key)
        # with open(file_name[:-4] + ".dec", 'wb') as fo:
        self.decryptedFileName = newFileName + ".DECRYPTED" + newFileExtension
        with open(newFileName + ".DECRYPTED" + newFileExtension, 'wb') as fileOperation:
            fileOperation.write(dec)


if __name__ == '__main__':
    # Initialing Diffie Hellman key exchange secure communication
    alicePrivateKey = int(input('\033[34m' + "Enter private key for alice: " + '\033[m'))
    bobPrivateKey = int(input('\033[34m' + "Enter private key for bob: " + '\033[m'))
    alice = diffieHellmanSC(privateKey=alicePrivateKey)
    bob = diffieHellmanSC(p=alice.p, g=alice.g, privateKey=bobPrivateKey)

    # Generating Key for alice and bob
    alice.generateKey(bob.publicKey)
    bob.generateKey(alice.publicKey)

    # Using Blum Blum Shub PRNG to generate secret key
    bbsCSPRNGGenerator = CSPRNG()
    productOfBigPrime = 1009 * 1031
    alice.getKey()
    bob.getKey()
    seedOfKey = hash(alice.sharedKey)
    encryptSharedKey = bbsCSPRNGGenerator.bbsEncryptDecrypt(alice.sharedKey, productOfBigPrime, seedOfKey)
    decryptSharedKey = bbsCSPRNGGenerator.bbsEncryptDecrypt(encryptSharedKey, productOfBigPrime, seedOfKey)
    bbsEncryptedToHex = binascii.hexlify(encryptSharedKey.encode('utf-8'))
    hexToPlainText = bbsEncryptedToHex.decode('utf-8')

    # File encryption using AES
    # please install the package [pip3 install pycryptodome]
    # Tested only with .txt file
    encDecFile = aesFileEncryption()

    print("*************** Alice ***************")
    alice.showDHKeyExchange("prime")
    alice.showDHKeyExchange("generator")
    alice.showDHKeyExchange("privatekey")
    alice.showDHKeyExchange("publickey")
    alice.showDHKeyExchange("sharedsecret")
    alice.showDHKeyExchange("sharedkey")
    print("BBS generated secret key: " + hexToPlainText)
    choiceFileName = input('\033[34m' + "Enter file name to encrypt: " + '\033[m')
    encDecFile.encryptFile(choiceFileName, encryptSharedKey.encode('utf-8'))
    print("File encryption successful. New file name is: " + '\033[31m' + encDecFile.encryptedFileName + '\033[m')

    print("*************** Bob ***************")
    bob.showDHKeyExchange("prime")
    bob.showDHKeyExchange("generator")
    bob.showDHKeyExchange("privatekey")
    bob.showDHKeyExchange("publickey")
    bob.showDHKeyExchange("sharedsecret")
    bob.showDHKeyExchange("sharedkey")
    print("BBS generated secret key: " + hexToPlainText)
    choiceFileName = input('\033[34m' + "Enter file name to decrypt: " + '\033[m')
    encDecFile.decryptFile(choiceFileName, encryptSharedKey.encode('utf-8'))
    print("File decryption successful. New file name is: " + '\033[31m' + encDecFile.decryptedFileName + '\033[m')

    '''
    print(hexToPlainText)
    reverseBBSHexToEncrypted = bytes.fromhex(hexToPlainText).decode('utf-8')
    print(reverseBBSHexToEncrypted)
    if (alice.getKey() == bob.getKey()):
        print ("Alice" & Bob")
    else:
        print("Shared keys does not match")
    '''
